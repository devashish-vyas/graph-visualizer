{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","PathfindingVisualizer/Algorithms/dfs.js","PathfindingVisualizer/Algorithms/dijkstra.js","PathfindingVisualizer/Mazes/maze.js","PathfindingVisualizer/Mazes/weightMaze.js","Navbar.js","PathfindingVisualizer/Mazes/hSkewMaze.js","PathfindingVisualizer/Mazes/vSkewMaze.js","Data Structures/disjointSetItem.js","Data Structures/disjointSet.js","PathfindingVisualizer/Mazes/kruskalsMaze1.js","PathfindingVisualizer/Mazes/primsMaze.js","PathfindingVisualizer/PathfindingVisualizer.js","PathfindingVisualizer/Mazes/wallMaze.js","PathfindingVisualizer/Algorithms/bfs.js","Canvas/CanvasContext.js","Canvas/CanvasBoard.js","Canvas/Algorithms/bfs.js","Canvas/Algorithms/dfs.js","Canvas/Algorithms/dijkstra.js","Canvas/Algorithms/visitAllEdges.js","Canvas/Algorithms/kruskals.js","Canvas/Algorithms/prims.js","Canvas/Canvas.js","App.js","index.js"],"names":["Node","props","this","row","col","weight","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","extraClassName","id","className","React","Component","getChildren","node","grid","childElements","forEach","direction","childRow","childCol","length","child","isVisited","push","childNodes","childNode","costFromSource","parent","Math","min","extractMinIndex","dijkstraPQ","minNode","minNodeIndex","i","currentNode","createNode","finishNode","startNode","srow","scol","frow","fcol","isNode","Number","POSITIVE_INFINITY","removeWall","nodeA","nodeB","rowA","colA","rowB","colB","r","floor","c","maze","rowNum","colNum","newNode","initialGrid","dfsStack","random","pop","weightMaze","Navbar","onVisualizeClick","state","visualize","bfs","dfs","dijkstra","alert","toggleCanvas","bfsClick","setState","dfsClick","dijkstraClick","onWeightWallToggleClick","weightOrWall","weightWallToggle","isCanvas","clearGrid","resetGrid","mazify","hmazify","vmazify","kruskalMazify","primMazify","weightMazify","wallMazify","clearWallsandWeights","kruskalMST","primMST","mazeOptions","data-toggle","href","onClick","weightAndWallOption","addWeightOption","type","vChildElements","hChildElements","horizontalSkewMaze","random1","verticalSkewMaze","DisjointSetItem","value","keyCallback","children","isRoot","getRoot","rank","getRank","Object","values","parentItem","forceSettingParentChild","addChild","childItem","getKey","setParent","DisjointSet","items","itemValue","disjointSetItem","templateDisjointItem","requiredDisjointItem","valueA","valueB","rootKeyA","find","rootKeyB","Error","rootA","rootB","disjointSet","index","hWallSet","vWallSet","kruskalMaze","makeSet","random2","neighborNodeRight","neighborNodeLeft","inSameSet","union","splice","unionJoint","primMaze","edgeQueue","PathfindingVisualizer","toggleIsRunning","isRunning","toggleWeightWallToggle","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","getInitialGrid","rowCount","ROW_COUNT","colCount","COLUMN_COUNT","currentRow","document","getElementById","onCellDown","mouseIsPressed","startNodePressed","finishNodePressed","onCellEnter","onCellLeave","onCellRelease","mazes","mazeType","wallMaze","componentWillMount","documentElement","clientHeight","clientWidth","componentDidMount","nodesInShortestPathOrder","unshift","algo","visitedNodesInOrder","minIndex","bfsQueue","childDirections","shift","x","y","getNodesInShortestPathOrder","animate","setTimeout","animateShortestPath","nodeClassName","navbarHeight","map","rowID","nodeID","CanvasContext","createContext","CanvasProvider","useState","isDrawing","setIsDrawing","nodeDrawing","setNodeDrawing","setIndex","canvasRef","useRef","contextRef","nodesOfGraph","pushNode","squareDistance","pow","centerX","centerY","setStartNode","currentCoordinates","whichNode","writeText","info","style","canvas","current","ctx","getContext","text","fontSize","fontFamily","color","textAlign","textBaseline","beginPath","font","fillStyle","fillText","stroke","currentEdgeWeight","setCurrentEdgeWeight","Provider","prepareCanvas","height","width","context","lineCap","strokeStyle","lineWidth","startDrawing","nativeEvent","offsetX","offsetY","prevIndex","arc","PI","closePath","start","moveTo","finishDrawing","end","lineTo","clearCanvas","fillRect","draw","toggleNodeDrawing","CanvasBoard","useContext","useEffect","settingStartNode","settingEndNode","endNode","setEndNode","settingGraph","emptyGraphCall","toggleEmptyTheGraph","setWeight","edgeWeightInput","onChange","event","parseInt","target","class","placeholder","startIndex","endIndex","onMouseMove","ref","graph","visitedEdgesInOrder","xB","yB","xA","yA","createEdge","childObject","compare","edgeA","edgeB","edgeWeight","getEdgeWeight","Canvas","canvasOrGrid","graphOfNodes","redrawGraph","edge","visitAllEdges","fill","shortestPathNodes","visualizeMST","MSTedges","graphEdges","sort","kruskalSelectedEdges","kruskalsMST","primSelectedEdges","graphEdgesQueue","primsMST","animateMST","visitedNodesInOrder1","visitedEdgesInOrder1","console","log","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ed18144f.chunk.js","sourcesContent":["// jsx for each node AKA eac cel on the grid\nimport React from 'react';\nimport './Node.css'\nclass Node extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n    render() {\n        const {\n            row,\n            col,\n            weight,\n            isFinish,\n            isStart,\n            isWall,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp,\n            onMouseLeave,\n        } = this.props;\n        const extraClassName = isFinish ? \"node-finish\" : isStart ? \"node-start\" : isWall ? \"node-wall\" : \"\";\n        return (\n            <td\n                id={`node-${row}-${col}`}\n                className={`node ${extraClassName}`}\n                onMouseDown={() => onMouseDown(row, col)}\n                onMouseEnter={() => onMouseEnter(row, col)}\n                onMouseUp={() => onMouseUp()}\n                onMouseLeave={() => onMouseLeave(row, col)}\n            ><b>{weight === 1 ? \"\" : weight}</b></td> // It is used to create the grid.\n        );\n    }\n}\nexport default Node;","// DFS\n\nfunction getChildren(node, grid) {\n    const { row, col } = node;\n    const childElements = [];\n    const childDirections = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\n    childDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited && !child.isWall) {\n                childElements.push(child);\n            }\n        }\n    })\n\n    return childElements;\n}\n\n\nexport function dfs(grid,startNode,finishNode){\n    const visitedNodesInOrder = [startNode];\n    startNode.isVisited= true;\n    let currentNode = startNode;\n    let dfsStack = [currentNode];\n    while (dfsStack.length) {\n        if(currentNode.isFinish) return visitedNodesInOrder;\n        const childElements = getChildren(currentNode, grid);\n        if (childElements.length) {\n            childElements[0].parent = currentNode;\n            currentNode = childElements[0];\n            currentNode.isVisited = true;\n            visitedNodesInOrder.push(currentNode);\n            dfsStack.push(currentNode);\n        }\n        else { \n            dfsStack.pop();\n            currentNode = dfsStack[dfsStack.length-1];\n        }\n    }\n    return visitedNodesInOrder;\n}\n","// Dijkstra\n\nfunction getChildren (grid,node){\n    const childDirections = [[1,0],[0,1],[-1,0],[0,-1]];\n    const childNodes = [];\n    const {row,col} = node;\n    childDirections.forEach(direction=>{\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n\n        if(childRow >=0&& childCol>=0 && childCol<grid[0].length && childRow<grid.length)\n        {\n            const childNode = grid[childRow][childCol];\n            if(!childNode.isVisited && !childNode.isWall)\n            {\n                childNodes.push(childNode);\n                if(childNode.costFromSource > node.costFromSource + childNode.weight)\n                {\n                    childNode.parent = node;\n                }\n                childNode.costFromSource = Math.min(childNode.costFromSource, node.costFromSource + childNode.weight);\n            }\n            else if(childNode.isVisited)\n            {\n                if (childNode.costFromSource > node.costFromSource + childNode.weight) {\n                    childNode.parent = node;\n                }\n                childNode.costFromSource = Math.min(childNode.costFromSource, node.costFromSource + childNode.weight);\n            }\n        }\n    })\n    return childNodes;\n}\n\nfunction extractMinIndex (dijkstraPQ){\n    let minNode = dijkstraPQ[0];\n    let minNodeIndex=0;\n    for(let i=1;i<dijkstraPQ.length;i++)\n    {\n        let currentNode = dijkstraPQ[i];\n        if(minNode.costFromSource > currentNode.costFromSource)\n        {\n            minNode = currentNode;\n            minNodeIndex = i;\n        }\n    }\n    return minNodeIndex;\n}\n\nexport function dijkstra(grid,startNode,finishNode){\n    const visitedNodesInOrder = [];\n\n    let currentNode;\n    let dijkstraPQ = [startNode];\n    startNode.isVisited=true;\n    while(dijkstraPQ.length)\n    {\n        const minIndex = extractMinIndex(dijkstraPQ);\n        currentNode = dijkstraPQ[minIndex];\n        if(currentNode.isFinish) return visitedNodesInOrder;\n\n        visitedNodesInOrder.push(currentNode);\n        const childNodes = getChildren(grid,currentNode);\n        childNodes.forEach(node => {\n            dijkstraPQ.push(node);\n            node.isVisited=true;\n        });\n        dijkstraPQ.splice(minIndex,1);\n    }\n    return visitedNodesInOrder;\n}\n\n","function createNode(row, col, finishNode, startNode) {\n    const srow = startNode.row;\n    const scol = startNode.col;\n    const frow = finishNode.row;\n    const fcol = finishNode.col;\n    return {\n        row: row,\n        col: col,\n        isVisited: false,\n        isWall: false,\n        parent: null,\n        isNode: true,\n        isStart:\n            row === srow && col === scol,\n        isFinish:\n            row === frow && col === fcol,\n        weight: 1,\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\n    };\n}\n\n// assumed rowNum ans colNum are odd\n\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\n    const grid = [];\n    for (let r = 0; r < rowNum; r++) {\n        const row = [];\n        for (let c = 0; c < colNum; c++) {\n            const newNode = createNode(r, c, finishNode, startNode);\n            if ((r % 2 == 0 || c % 2 == 0)) newNode.isWall = true;\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\n            row.push(newNode);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\n\nfunction getChildren(node, grid) {\n    const { row, col } = node;\n    const childElements = [];\n    const childDirections = [[2, 0], [0, 2], [-2, 0], [0, -2]];\n\n    childDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited) {\n                // child.isVisited = true;\n                childElements.push(child);\n            }\n        }\n    })\n\n    return childElements;\n}\n\nfunction removeWall(nodeA, nodeB, grid) {\n\n    const rowA = nodeA.row;\n    const colA = nodeA.col;\n    const rowB = nodeB.row;\n    const colB = nodeB.col;\n\n    const r = Math.floor((rowA + rowB) / 2);\n    const c = Math.floor((colA + colB) / 2);\n\n    grid[r][c].isWall = false;\n    return;\n}\n\nexport function maze(rowNum, colNum, startNode, finishNode) {\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\n\n    let currentNode = grid[1][1];\n    let dfsStack = [currentNode];\n\n    while (dfsStack.length) {\n        const childElements = getChildren(currentNode, grid);\n        if (childElements.length) {\n            const random = Math.floor(Math.random() * childElements.length);\n            removeWall(currentNode, childElements[random], grid);\n            currentNode = childElements[random];\n            currentNode.isVisited = true;\n            dfsStack.push(currentNode);\n        }\n        else {\n            currentNode = dfsStack.pop();\n        }\n    }\n    grid.forEach(row => {\n        row.forEach(node => {\n            node.isVisited = false;\n        });\n    });\n    return grid;\n}\n\n","function distribution() {\n    const random1 = Math.random();\n    if (random1 < 0.5) {\n        const random2 = Math.floor(Math.random() * 10 + 1);\n        return random2;\n    }\n    return 1;\n}\nexport function weightMaze(grid) {\n    grid.forEach(row => {\n        row.forEach(node => {\n            if (!node.isWall) {\n                node.weight = distribution();\n            }\n        });\n    });\n    return grid;\n}","import React from 'react';\nclass Navbar extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            visualize: '',\n            weightOrWall: false,\n            isCanvas: this.props.isCanvas,\n        }\n    }\n    onVisualizeClick = () => {\n        const visualize = this.state.visualize;\n        switch (visualize) {\n            case 'BFS':\n                this.props.bfs();\n                break;\n            case 'DFS':\n                this.props.dfs();\n                break;\n            case 'Dijkstra':\n                this.props.dijkstra();\n                break;\n            default:\n                alert('Choose an algorithm for visualization!!');\n        }\n    }\n    toggleCanvas = () => {\n        this.props.toggleCanvas();\n    }\n    bfsClick = () => {\n        this.setState({ visualize: 'BFS' });\n    }\n    dfsClick = () => {\n        this.setState({ visualize: 'DFS' });\n    }\n    dijkstraClick = () => {\n        this.setState({ visualize: 'Dijkstra' });\n    }\n    onWeightWallToggleClick = () => {\n        const weightOrWall = !this.state.weightOrWall;\n        this.setState({ weightOrWall });\n        this.props.weightWallToggle();\n    }\n    render() {\n        const {\n            clearGrid,\n            resetGrid,\n            mazify,\n            hmazify,\n            vmazify,\n            kruskalMazify,\n            primMazify,\n            weightMazify,\n            wallMazify,\n            clearWallsandWeights,\n            kruskalMST,\n            primMST,\n        } = this.props;\n\n        let mazeOptions = <li className=\"dropdown\">\n            <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Mazes &amp; Patterns\n             <span className=\"caret\"></span></a>\n            <ul className=\"dropdown-menu\">\n                <li id='startButtonCreateMazeTwo'><a href=\"#\" onClick={mazify}>Recursive Division</a></li>\n                <li id='startButtonCreateMazeThree'><a href=\"#\" onClick={vmazify}>Recursive Division (vertical skew)</a></li>\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={hmazify}>Recursive Division (horizontal skew)</a></li>\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={kruskalMazify}>Kruskal's Maze</a></li>\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={primMazify}>Prims's Maze</a></li>\n                <li id='startButtonCreateMazeOne'><a href=\"#\" onClick={wallMazify}>Basic Random Maze</a></li>\n                <li id='startButtonCreateMazeWeights'><a href=\"#\" onClick={weightMazify}>Basic Weight Maze</a></li>\n            </ul>\n        </li>;\n        let weightAndWallOption = <li id='startButtonClearWalls'><a href=\"#\" onClick={clearWallsandWeights}>Clear Walls &amp; Weights</a></li>;\n        let addWeightOption = <li id='startButtonAddObject'><a href=\"#\" onClick={this.onWeightWallToggleClick}>Add {this.state.weightOrWall ? 'Wall' : 'Weight'}</a></li>;\n        if(this.state.isCanvas){\n            mazeOptions = <li className=\"dropdown\">\n                <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Minimum Spanning Tree\n             <span className=\"caret\"></span></a>\n                <ul className=\"dropdown-menu\">\n                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={kruskalMST}>Kruskal's Algorithm</a></li>\n                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={primMST}>Prims's Algorithm</a></li>\n                </ul>\n            </li>;\n            weightAndWallOption = <li></li>;\n            addWeightOption = <li></li>;\n        }\n\n        return (\n            <div id='navbarDiv'>\n                <nav className=\"navbar navbar-inverse\">\n                    <div className=\"container-fluid\">\n                        <div className=\"navbar-header\">\n                            <a id=\"refreshButton\" className=\"navbar-brand\" href=\"#\">Graph Visualizer</a>\n                        </div>\n                        <ul className=\"nav navbar-nav\">\n                            <li className=\"dropdown\">\n                                <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Algorithms\n             <span className=\"caret\"></span></a>\n                                <ul className=\"dropdown-menu\">\n                                    <li id='startButtonDijkstra'><a href=\"#\" onClick={this.dijkstraClick}>Dijkstra's Algorithm</a></li>\n                                    <li id='startButtonBFS'><a href=\"#\" onClick={this.bfsClick}>Breadth-first Search</a></li>\n                                    <li id='startButtonDFS'><a href=\"#\" onClick={this.dfsClick}>Depth-first Search</a></li>\n                                </ul>\n                            </li>\n                            {mazeOptions}\n                            {addWeightOption}\n                            <li id='startButtonStart'><button id=\"actualStartButton\" className=\"btn btn-default navbar-btn\" type=\"button\" onClick={this.onVisualizeClick}>Visualize {this.state.visualize}!</button></li>\n                            <li id='startButtonClearBoard'><a href=\"#\" onClick={resetGrid}>Clear Board</a></li>\n                            {weightAndWallOption}\n                            <li id='startButtonClearPath'><a href=\"#\" onClick={clearGrid}>Clear Path</a></li>\n                            <li id='startButtonAddObject'><a href=\"#\" onClick={this.toggleCanvas}>Switch to {this.state.isCanvas ? 'Grid' : 'Canvas'}</a></li>\n                        </ul>\n                    </div>\n                </nav>\n            </div>\n        );\n    }\n}\n\nexport default Navbar;","function createNode(row, col, finishNode, startNode) {\n    const srow = startNode.row;\n    const scol = startNode.col;\n    const frow = finishNode.row;\n    const fcol = finishNode.col;\n    return {\n        row: row,\n        col: col,\n        isVisited: false,\n        isWall: false,\n        parent: null,\n        isNode: true,\n        isStart:\n            row === srow && col === scol,\n        isFinish:\n            row === frow && col === fcol,\n        weight: 1,\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\n    };\n}\n\n// assumed rowNum ans colNum are odd\n\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\n    const grid = [];\n    for (let r = 0; r < rowNum; r++) {\n        const row = [];\n        for (let c = 0; c < colNum; c++) {\n            const newNode = createNode(r, c, finishNode, startNode);\n            if ((r % 2 == 0 || c % 2 == 0)) newNode.isWall = true;\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\n            row.push(newNode);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\n\nfunction getChildren(node, grid) {\n    const { row, col } = node;\n    const childElements = [];\n    const hChildDirections = [[2, 0], [-2, 0]];\n    const vChildDirections = [[0, 2], [0, -2]];\n\n    const vChildElements = [];\n    vChildDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited) {\n                vChildElements.push(child);\n            }\n        }\n    });\n    childElements.push(vChildElements);\n\n    const hChildElements = [];\n    hChildDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited) {\n                hChildElements.push(child);\n            }\n        }\n    });\n    childElements.push(hChildElements);\n\n    return childElements;\n}\n\nfunction removeWall(nodeA, nodeB, grid) {\n\n    const rowA = nodeA.row;\n    const colA = nodeA.col;\n    const rowB = nodeB.row;\n    const colB = nodeB.col;\n\n    const r = Math.floor((rowA + rowB) / 2);\n    const c = Math.floor((colA + colB) / 2);\n\n    grid[r][c].isWall = false;\n    return;\n}\n\nexport function horizontalSkewMaze(rowNum, colNum, startNode, finishNode) {\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\n\n    let currentNode = grid[1][1];\n    let dfsStack = [currentNode];\n\n    while (dfsStack.length) {\n        const childElements = getChildren(currentNode, grid);\n        if (childElements[0].length || childElements[1].length) {\n            const random1 = Math.floor(Math.random() * 4);\n            if (random1 !== 3 && childElements[0].length) {\n                const random = Math.floor(Math.random() * childElements[0].length);\n                removeWall(currentNode, childElements[0][random], grid);\n                currentNode = childElements[0][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else if (random1 === 3 && childElements[1].length) {\n                const random = Math.floor(Math.random() * childElements[1].length);\n                removeWall(currentNode, childElements[1][random], grid);\n                currentNode = childElements[1][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else if (childElements[1].length) {\n                const random = Math.floor(Math.random() * childElements[1].length);\n                removeWall(currentNode, childElements[1][random], grid);\n                currentNode = childElements[1][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else {\n                const random = Math.floor(Math.random() * childElements[0].length);\n                removeWall(currentNode, childElements[0][random], grid);\n                currentNode = childElements[0][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n        }\n        else {\n            currentNode = dfsStack.pop();\n        }\n    }\n    grid.forEach(row => {\n        row.forEach(node => {\n            node.isVisited = false;\n        });\n    });\n    return grid;\n}","function createNode(row, col, finishNode, startNode) {\n    const srow = startNode.row;\n    const scol = startNode.col;\n    const frow = finishNode.row;\n    const fcol = finishNode.col;\n    return {\n        row: row,\n        col: col,\n        isVisited: false,\n        isWall: false,\n        parent: null,\n        isNode: true,\n        isStart:\n            row === srow && col === scol,\n        isFinish:\n            row === frow && col === fcol,\n        weight: 1,\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\n    };\n}\n\n// assumed rowNum ans colNum are odd\n\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\n    const grid = [];\n    for (let r = 0; r < rowNum; r++) {\n        const row = [];\n        for (let c = 0; c < colNum; c++) {\n            const newNode = createNode(r, c, finishNode, startNode);\n            if ((r % 2 == 0 || c % 2 == 0)) newNode.isWall = true;\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\n            row.push(newNode);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\n\nfunction getChildren(node, grid) {\n    const { row, col } = node;\n    const childElements = [];\n    const hChildDirections = [[2, 0], [-2, 0]];\n    const vChildDirections = [[0, 2], [0, -2]];\n\n    const hChildElements = [];\n    hChildDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited) {\n                hChildElements.push(child);\n            }\n        }\n    });\n    childElements.push(hChildElements);\n\n    const vChildElements = [];\n    vChildDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited) {\n                vChildElements.push(child);\n            }\n        }\n    });\n    childElements.push(vChildElements);\n    return childElements;\n}\n\nfunction removeWall(nodeA, nodeB, grid) {\n\n    const rowA = nodeA.row;\n    const colA = nodeA.col;\n    const rowB = nodeB.row;\n    const colB = nodeB.col;\n\n    const r = Math.floor((rowA + rowB) / 2);\n    const c = Math.floor((colA + colB) / 2);\n\n    grid[r][c].isWall = false;\n    return;\n}\n\nexport function verticalSkewMaze(rowNum, colNum, startNode, finishNode) {\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\n\n    let currentNode = grid[1][1];\n    let dfsStack = [currentNode];\n\n    while (dfsStack.length) {\n        const childElements = getChildren(currentNode, grid);\n        if (childElements[0].length || childElements[1].length) {\n            const random1 = Math.floor(Math.random() * 4);\n            if (random1 !== 3 && childElements[0].length) {\n                const random = Math.floor(Math.random() * childElements[0].length);\n                removeWall(currentNode, childElements[0][random], grid);\n                currentNode = childElements[0][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else if (random1 === 3 && childElements[1].length) {\n                const random = Math.floor(Math.random() * childElements[1].length);\n                removeWall(currentNode, childElements[1][random], grid);\n                currentNode = childElements[1][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else if (childElements[1].length) {\n                const random = Math.floor(Math.random() * childElements[1].length);\n                removeWall(currentNode, childElements[1][random], grid);\n                currentNode = childElements[1][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else {\n                const random = Math.floor(Math.random() * childElements[0].length);\n                removeWall(currentNode, childElements[0][random], grid);\n                currentNode = childElements[0][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n        }\n        else {\n            currentNode = dfsStack.pop();\n        }\n    }\n    grid.forEach(row => {\n        row.forEach(node => {\n            node.isVisited = false;\n        });\n    });\n    return grid;\n}\n\n","export default class DisjointSetItem {\n    /**\n     * @param {*} value\n     * @param {function(value: *)} [keyCallback]\n     */\n    constructor(value, keyCallback) {\n        this.value = value;\n        this.keyCallback = keyCallback;\n        /** @var {DisjointSetItem} this.parent */\n        this.parent = null;\n        this.children = {};\n    }\n\n    /**\n     * @return {*}\n     */\n    getKey() {\n        // Allow user to define custom key generator.\n        if (this.keyCallback) {\n            return this.keyCallback(this.value);\n        }\n\n        // Otherwise use value as a key by default.\n        return this.value;\n    }\n\n    /**\n     * @return {DisjointSetItem}\n     */\n    getRoot() {\n        return this.isRoot() ? this : this.parent.getRoot();\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isRoot() {\n        return this.parent === null;\n    }\n\n    /**\n     * Rank basically means the number of all ancestors.\n     *\n     * @return {number}\n     */\n    getRank() {\n        if (this.getChildren().length === 0) {\n            return 0;\n        }\n\n        let rank = 0;\n\n        /** @var {DisjointSetItem} child */\n        this.getChildren().forEach((child) => {\n            // Count child itself.\n            rank += 1;\n\n            // Also add all children of current child.\n            rank += child.getRank();\n        });\n\n        return rank;\n    }\n\n    /**\n     * @return {DisjointSetItem[]}\n     */\n    getChildren() {\n        return Object.values(this.children);\n    }\n\n    /**\n     * @param {DisjointSetItem} parentItem\n     * @param {boolean} forceSettingParentChild\n     * @return {DisjointSetItem}\n     */\n    setParent(parentItem, forceSettingParentChild = true) {\n        this.parent = parentItem;\n        if (forceSettingParentChild) {\n            parentItem.addChild(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {DisjointSetItem} childItem\n     * @return {DisjointSetItem}\n     */\n    addChild(childItem) {\n        this.children[childItem.getKey()] = childItem;\n        childItem.setParent(this, false);\n\n        return this;\n    }\n}","import DisjointSetItem from './disjointSetItem';\n\nexport default class DisjointSet {\n    /**\n     * @param {function(value: *)} [keyCallback]\n     */\n    constructor(keyCallback) {\n        this.keyCallback = keyCallback;\n        this.items = {};\n    }\n\n    /**\n     * @param {*} itemValue\n     * @return {DisjointSet}\n     */\n    makeSet(itemValue) {\n        const disjointSetItem = new DisjointSetItem(itemValue, this.keyCallback);\n\n        if (!this.items[disjointSetItem.getKey()]) {\n            // Add new item only in case if it not presented yet.\n            this.items[disjointSetItem.getKey()] = disjointSetItem;\n        }\n\n        return this;\n    }\n\n    /**\n     * Find set representation node.\n     *\n     * @param {*} itemValue\n     * @return {(string|null)}\n     */\n    find(itemValue) {\n        const templateDisjointItem = new DisjointSetItem(itemValue, this.keyCallback);\n\n        // Try to find item itself;\n        const requiredDisjointItem = this.items[templateDisjointItem.getKey()];\n\n        if (!requiredDisjointItem) {\n            return null;\n        }\n\n        return requiredDisjointItem.getRoot().getKey();\n    }\n\n    /**\n     * Union by rank.\n     *\n     * @param {*} valueA\n     * @param {*} valueB\n     * @return {DisjointSet}\n     */\n    union(valueA, valueB) {\n        const rootKeyA = this.find(valueA);\n        const rootKeyB = this.find(valueB);\n\n        if (rootKeyA === null || rootKeyB === null) {\n            throw new Error('One or two values are not in sets');\n        }\n\n        if (rootKeyA === rootKeyB) {\n            // In case if both elements are already in the same set then just return its key.\n            return this;\n        }\n\n        const rootA = this.items[rootKeyA];\n        const rootB = this.items[rootKeyB];\n\n        if (rootA.getRank() < rootB.getRank()) {\n            // If rootB's tree is bigger then make rootB to be a new root.\n            rootB.addChild(rootA);\n\n            return this;\n        }\n\n        // If rootA's tree is bigger then make rootA to be a new root.\n        rootA.addChild(rootB);\n\n        return this;\n    }\n\n    /**\n     * @param {*} valueA\n     * @param {*} valueB\n     * @return {boolean}\n     */\n    inSameSet(valueA, valueB) {\n        const rootKeyA = this.find(valueA);\n        const rootKeyB = this.find(valueB);\n\n        if (rootKeyA === null || rootKeyB === null) {\n            throw new Error('One or two values are not in sets');\n        }\n\n        return rootKeyA === rootKeyB;\n    }\n}","// with data structure\n// working fine\nimport DisjointSet from '../../Data Structures/disjointSet';\nlet disjointSet = new DisjointSet((node) => {\n    return node.index;\n});\nfunction createNode(row, col, finishNode, startNode) {\n    const srow = startNode.row;\n    const scol = startNode.col;\n    const frow = finishNode.row;\n    const fcol = finishNode.col;\n    return {\n        row: row,\n        col: col,\n        isVisited: false,\n        isWall: false,\n        parent: null,\n        isNode: true,\n        isStart:\n            row === srow && col === scol,\n        isFinish:\n            row === frow && col === fcol,\n        weight: 1,\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\n        index: -1,\n    };\n}\nlet hWallSet = [];\nlet vWallSet = [];\nlet rootNodeIndex = [];\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\n    disjointSet = new DisjointSet((node) => {\n        return node.index;\n    });\n    hWallSet = [];\n    vWallSet = [];\n    const grid = [];\n    let i = 0;\n    for (let r = 0; r < rowNum; r++) {\n        const row = [];\n        for (let c = 0; c < colNum; c++) {\n            const newNode = createNode(r, c, finishNode, startNode);\n            if ((r % 2 == 0 || c % 2 == 0)) {\n                newNode.isWall = true;\n                if (c % 2 === 0 && r % 2 === 1 && c > 0 && c < colNum - 1) {\n                    hWallSet.push(newNode);\n                }\n                else if (r % 2 === 0 && c % 2 === 1 && r > 0 && r < rowNum - 1) {\n                    vWallSet.push(newNode);\n                }\n            }\n            else {\n                newNode.index = i;\n                // rootNodeIndex.push(i);\n                i++;\n                disjointSet.makeSet(newNode);\n            }\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\n            row.push(newNode);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\nexport function kruskalMaze(rowNum, colNum, startNode, finishNode) {\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\n    while (hWallSet.length || vWallSet.length) {\n        const random1 = Math.floor(Math.random() * 2);\n        if (random1 && hWallSet.length) {\n            const random2 = Math.floor(Math.random() * hWallSet.length);\n            const node = hWallSet[random2];\n            const { row, col } = node;\n            const neighborNodeRight = grid[row][col + 1];\n            const neighborNodeLeft = grid[row][col - 1];\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\n                node.isWall = false;\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\n            }\n            hWallSet.splice(random2, 1);\n        }\n        else if (!random1 && vWallSet.length) {\n            const random2 = Math.floor(Math.random() * vWallSet.length);\n            const node = vWallSet[random2];\n            const { row, col } = node;\n            const neighborNodeRight = grid[row + 1][col];\n            const neighborNodeLeft = grid[row - 1][col];\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\n                node.isWall = false;\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\n            }\n            vWallSet.splice(random2, 1);\n        }\n        else if (hWallSet.length) {\n            const random2 = Math.floor(Math.random() * hWallSet.length);\n            const node = hWallSet[random2];\n            const { row, col } = node;\n            const neighborNodeRight = grid[row][col + 1];\n            const neighborNodeLeft = grid[row][col - 1];\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\n                node.isWall = false;\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\n            }\n            hWallSet.splice(random2, 1);\n        }\n        else if (vWallSet.length) {\n            const random2 = Math.floor(Math.random() * vWallSet.length);\n            const node = vWallSet[random2];\n            const { row, col } = node;\n            const neighborNodeRight = grid[row + 1][col];\n            const neighborNodeLeft = grid[row - 1][col];\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\n                node.isWall = false;\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\n            }\n            vWallSet.splice(random2, 1);\n        }\n    }\n    return grid;\n}","import DisjointSet from '../../Data Structures/disjointSet';\nlet disjointSet = new DisjointSet((node) => {\n    return node.index;\n});\n\nfunction createNode(row, col, finishNode, startNode) {\n    const srow = startNode.row;\n    const scol = startNode.col;\n    const frow = finishNode.row;\n    const fcol = finishNode.col;\n    return {\n        row: row,\n        col: col,\n        isVisited: false,\n        isWall: false,\n        parent: null,\n        isNode: true,\n        isStart:\n            row === srow && col === scol,\n        isFinish:\n            row === frow && col === fcol,\n        weight: 1,\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\n        index: -1,\n    };\n}\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\n    disjointSet = new DisjointSet((node) => {\n        return node.index;\n    });\n    const grid = [];\n    let i = 0;\n    for (let r = 0; r < rowNum; r++) {\n        const row = [];\n        for (let c = 0; c < colNum; c++) {\n            const newNode = createNode(r, c, finishNode, startNode);\n            if ((r % 2 == 0 || c % 2 == 0)) {\n                newNode.isWall = true;\n            }\n            else {\n                newNode.index = i;\n                i++;\n                disjointSet.makeSet(newNode);\n            }\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\n            row.push(newNode);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\n\nfunction getChildren(node, grid) {\n    const childDirection = [[2, 0], [0, 2], [-2, 0], [0, -2]];\n    const children = [];\n    const { row, col } = node;\n    childDirection.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow > 0 && childCol > 0 && childRow < grid.length && childCol < grid[0].length) {\n            const childNode = grid[childRow][childCol];\n            children.push(childNode);\n        }\n    });\n    return children;\n}\nfunction removeWall(nodeA, nodeB, grid) {\n\n    const rowA = nodeA.row;\n    const colA = nodeA.col;\n    const rowB = nodeB.row;\n    const colB = nodeB.col;\n\n    const r = Math.floor((rowA + rowB) / 2);\n    const c = Math.floor((colA + colB) / 2);\n\n    grid[r][c].isWall = false;\n    return;\n}\nfunction unionJoint(node, currentNode, grid) {\n    const children = getChildren(node, grid);\n    children.forEach(child => {\n        if (disjointSet.inSameSet(child, currentNode) && !disjointSet.inSameSet(currentNode, node)) {\n            removeWall(child, node, grid);\n            disjointSet.union(currentNode, node);\n        }\n    });\n    return;\n}\nexport function primMaze(rowNum, colNum, startNode, finishNode) {\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\n\n    let currentNode = grid[1][1];\n    const edgeQueue = [grid[3][1], grid[1][3]];\n    grid[3][1].isVisited = true;\n    grid[1][3].isVisited = true;\n    while (edgeQueue.length) {\n        const random = Math.floor(Math.random() * edgeQueue.length);\n        unionJoint(edgeQueue[random], currentNode, grid);\n        currentNode = edgeQueue[random];\n        const children = getChildren(currentNode, grid);\n        if (children.length) {\n            children.forEach(child => {\n                if (!child.isVisited) {\n                    edgeQueue.push(child);\n                    child.isVisited = true;\n                }\n            });\n        }\n        edgeQueue.splice(random, 1);\n    }\n    grid.forEach(row => {\n        row.forEach(node => {\n            node.isVisited = false;\n        });\n    });\n    return grid;\n}","import React from 'react';\nimport Node from './Node/Node';\nimport './PathfindingVisualizer.css'\nimport { bfs } from './Algorithms/bfs'\nimport { dfs } from './Algorithms/dfs'\nimport { dijkstra } from './Algorithms/dijkstra'\nimport { maze } from './Mazes/maze'\nimport { weightMaze } from './Mazes/weightMaze'\nimport { wallMaze } from './Mazes/wallMaze'\nimport Navbar from '../Navbar';\nimport { horizontalSkewMaze } from './Mazes/hSkewMaze';\nimport { verticalSkewMaze } from './Mazes/vSkewMaze';\nimport { kruskalMaze } from './Mazes/kruskalsMaze1';\nimport { primMaze } from './Mazes/primsMaze';\n\nclass PathfindingVisualizer extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            grid: [],\n            ROW_COUNT: 25,\n            COLUMN_COUNT: 35,\n            START_NODE_ROW: 5,\n            FINISH_NODE_ROW: 20,\n            START_NODE_COL: 5,\n            FINISH_NODE_COL: 30,\n            isRunning: false,                    // to check if any process is running at any instant\n            mouseIsPressed: false,               // to check if mouse is pressed at any instant\n            startNodePressed: false,             // to check if startnode is being dragged\n            finishNodePressed: false,            // to check if endnode is being dragged\n            weightWallToggle: false,\n        };\n\n    }\n\n    // Toggle state functions\n    toggleIsRunning = () => {\n        let isRunning = !this.state.isRunning;\n        this.setState({ isRunning });\n    }\n    toggleWeightWallToggle = () => {\n        const weightWallToggle = !this.state.weightWallToggle;\n        this.setState({ weightWallToggle });\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Function to create Node object\n    createNode = (row, col) => {\n        // returns a javascript object denoting a node\n        return {\n            row,\n            col,\n            isStart:\n                row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n            isFinish:\n                row === this.state.FINISH_NODE_ROW &&\n                col === this.state.FINISH_NODE_COL,\n            isVisited: false,\n            isWall: false,\n            parent: null,\n            isNode: true,\n            weight: 1,\n            costFromSource: (row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL) ? 0 : Number.POSITIVE_INFINITY,\n        };\n    };\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // grid related functions\n    // creates initial grid\n    getInitialGrid = (\n        rowCount = this.state.ROW_COUNT,\n        colCount = this.state.COLUMN_COUNT,\n    ) => {\n        const initialGrid = [];\n        for (let row = 0; row < rowCount; row++) {\n            const currentRow = [];\n            for (let col = 0; col < colCount; col++) {\n                currentRow.push(this.createNode(row, col));\n            }\n            initialGrid.push(currentRow);\n        }\n        return initialGrid;\n    };\n\n    // clear all animations from the grid\n    clearGrid = () => {\n        if (!this.state.isRunning) {\n            let grid = this.state.grid;\n\n            for (const row of grid) {\n                for (const node of row) {\n                    if (!node.isStart && !node.isFinish && !node.isWall) {\n                        document.getElementById(\n                            `node-${node.row}-${node.col}`\n                        ).className = 'node';\n                        node.isVisited = false;\n                        node.parent = null;\n                        node.costFromSource = Number.POSITIVE_INFINITY;\n                    }\n                    else if (node.isStart || node.isFinish) {\n                        node.parent = null;\n                        node.isVisited = false;\n                        if (node.isStart) node.costFromSource = 0;\n                        else node.costFromSource = Number.POSITIVE_INFINITY;\n                    }\n                }\n            }\n            this.setState({ grid });\n        }\n    }\n    \n    // clear all walls and weights from the grid\n    clearWallsandWeights = () => {\n        if (!this.state.isRunning) {\n            let grid = this.state.grid;\n\n            for (const row of grid) {\n                for (const node of row) {\n                    if (node.isWall) {\n                        document.getElementById(\n                            `node-${node.row}-${node.col}`\n                        ).className = 'node';\n                        node.isVisited = false;\n                        node.parent = null;\n                        node.isWall = false;\n                        node.costFromSource = Number.POSITIVE_INFINITY;\n                    }\n                    if (node.weight !== 1) {\n                        node.weight = 1;\n                        node.costFromSource = node.isStart ? 0 : Number.POSITIVE_INFINITY;\n                    }\n                }\n            }\n            this.setState({ grid });\n        }\n    }\n\n    // reset the grid\n    resetGrid = () => {\n        if (!this.state.isRunning) {\n            let grid = this.state.grid;\n\n            for (const row of grid) {\n                for (const node of row) {\n                    if (!node.isStart && !node.isFinish) {\n                        document.getElementById(\n                            `node-${node.row}-${node.col}`\n                        ).className = 'node';\n                        node.isVisited = false;\n                        node.parent = null;\n                        node.isWall = false;\n                        node.weight = 1;\n                    }\n                    else if (node.isStart || node.isFinish) {\n                        node.parent = null;\n                        node.isVisited = false;\n                        node.weight = 1;\n                    }\n                }\n            }\n            this.setState({ grid });\n        }\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // mouse event handlers\n    // fires on onMouseDown\n    onCellDown = (row, col) => {\n        if (!this.state.isRunning && !this.state.weightWallToggle) {\n\n            const grid = this.state.grid;\n            if (!this.state.mouseIsPressed) {\n                const mouseIsPressed = !this.state.mouseIsPressed;\n                this.setState({ mouseIsPressed });\n                const currentNode = grid[row][col];\n                if (!currentNode.isStart && !currentNode.isFinish) {\n                    if (currentNode.isWall) {\n                        document.getElementById(`node-${row}-${col}`).className = 'node';\n                        currentNode.isWall = false;\n                    }\n                    else {\n                        document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\n                        currentNode.isWall = true;\n                        currentNode.weight = 1;\n                    }\n                }\n                else if (currentNode.isStart) {\n                    const startNodePressed = !this.state.startNodePressed;\n                    this.setState({ startNodePressed });\n                    document.getElementById(`node-${row}-${col}`).className = 'node';\n                    currentNode.isStart = false;\n                }\n                else if (currentNode.isFinish) {\n                    const finishNodePressed = !this.state.finishNodePressed;\n                    this.setState({ finishNodePressed });\n                    document.getElementById(`node-${row}-${col}`).className = 'node';\n                    currentNode.isFinish = false;\n                }\n            }\n        }\n        else if (!this.state.isRunning && this.state.weightWallToggle) {\n            const grid = this.state.grid;\n            const currentNode = grid[row][col];\n            if (!currentNode.isWall) {\n                currentNode.weight = currentNode.weight + 1;\n            }\n        }\n    }\n\n    // fires on onMouseEnter\n    onCellEnter = (row, col) => {\n        if (!this.state.isRunning && this.state.mouseIsPressed) {\n            const grid = this.state.grid;\n            const currentNode = grid[row][col];\n            if (!currentNode.isStart && !currentNode.isFinish && !this.state.startNodePressed && !this.state.finishNodePressed) {\n                document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\n                currentNode.isWall = true;\n                currentNode.weight = 1;\n            }\n            else if (this.state.startNodePressed) {\n                const START_NODE_ROW = row;\n                const START_NODE_COL = col;\n                this.setState({ START_NODE_ROW, START_NODE_COL });\n                document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n            }\n            else if (this.state.finishNodePressed) {\n                const FINISH_NODE_ROW = row;\n                const FINISH_NODE_COL = col;\n                this.setState({ FINISH_NODE_ROW, FINISH_NODE_COL });\n                document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n            }\n\n        }\n    }\n\n    // fires on onMouseLeave\n    onCellLeave = (row, col) => {\n        const grid = this.state.grid;\n        if (this.state.startNodePressed) {\n            if (!grid[row][col].isFinish && !grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node';\n            else if (grid[row][col].isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n            else if (grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\n        }\n        else if (this.state.finishNodePressed) {\n            if (!grid[row][col].isStart && !grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node';\n            else if (grid[row][col].isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n            else if (grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\n        }\n    }\n\n    // fires on onMouseUp\n    onCellRelease = () => {\n        const mouseIsPressed = false;\n        const grid = this.state.grid;\n        if (this.state.startNodePressed) {\n            const row = this.state.START_NODE_ROW;\n            const col = this.state.START_NODE_COL;\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n            grid[row][col].isStart = true;\n            grid[row][col].isWall = false;\n        }\n        else if (this.state.finishNodePressed) {\n            const row = this.state.FINISH_NODE_ROW;\n            const col = this.state.FINISH_NODE_COL;\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n            grid[row][col].isFinish = true;\n            grid[row][col].isWall = false;\n        }\n        const startNodePressed = false;\n        const finishNodePressed = false;\n        this.setState({ mouseIsPressed, startNodePressed, finishNodePressed, grid });\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // animation functions\n    // backtraces shortest path from finishNode to startNode\n    getNodesInShortestPathOrder(finishNode) {\n        const nodesInShortestPathOrder = [];\n        let currentNode = finishNode;\n        while (currentNode !== null) {\n            nodesInShortestPathOrder.unshift(currentNode);\n            currentNode = currentNode.parent;\n        }\n        return nodesInShortestPathOrder;\n    }\n\n    // resposible for animating the grid\n    visualize(algo) {\n        if (!this.state.isRunning) {\n            this.clearGrid();\n            this.toggleIsRunning();\n            const { grid } = this.state;\n            const startNode =\n                grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n            const finishNode =\n                grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n            let visitedNodesInOrder;\n            switch (algo) {\n                case 'Dijkstra':\n                    visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n                    break;\n                case 'BFS':\n                    visitedNodesInOrder = bfs(grid, startNode, finishNode);\n                    break;\n                case 'DFS':\n                    visitedNodesInOrder = dfs(grid, startNode, finishNode);\n                    break;\n                default:\n                    // should never get here\n                    break;\n            }\n\n            const nodesInShortestPathOrder = this.getNodesInShortestPathOrder(finishNode);\n            nodesInShortestPathOrder.push('end');\n            this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n        }\n    }\n    animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length) {\n                setTimeout(() => {\n                    this.animateShortestPath(nodesInShortestPathOrder);\n                }, 2 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                const nodeClassName = document.getElementById(\n                    `node-${node.row}-${node.col}`,\n                ).className;\n                if (\n                    nodeClassName !== 'node node-start' &&\n                    nodeClassName !== 'node node-finish'\n                ) {\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\n                        'node node-visited';\n                }\n            }, 2 * i);\n        }\n    }\n\n    // responsible for animating shortest path\n    animateShortestPath(nodesInShortestPathOrder) {\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n            if (nodesInShortestPathOrder[i] === 'end') {\n                setTimeout(() => {\n                    this.toggleIsRunning();\n                }, i * 50);\n            } else {\n                setTimeout(() => {\n                    const node = nodesInShortestPathOrder[i];\n                    const nodeClassName = document.getElementById(\n                        `node-${node.row}-${node.col}`,\n                    ).className;\n                    if (\n                        nodeClassName !== 'node node-start' &&\n                        nodeClassName !== 'node node-finish'\n                    ) {\n                        document.getElementById(`node-${node.row}-${node.col}`).className =\n                            'node node-shortest-path';\n                    }\n                }, i * 40);\n            }\n        }\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // maze handler\n    mazes = (mazeType) => {\n        if (!this.state.isRunning) {\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n            let grid = this.state.grid;\n            switch (mazeType) {\n                case 'maze':\n                    grid = maze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\n                    break;\n                case 'hSkew':\n                    grid = horizontalSkewMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\n                    break;\n                case 'vSkew':\n                    grid = verticalSkewMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\n                    break;\n                case 'kruskals':\n                    grid = kruskalMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\n                    break;\n                case 'prims':\n                    grid = primMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\n                    break;\n                case 'weightMaze':\n                    grid = weightMaze(grid);\n                    break;\n                case 'wallMaze':\n                    grid = wallMaze(grid);\n                    break;\n            }\n            this.setState({ grid });\n        }\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // lifecycle functions\n    componentWillMount = () => {\n        const ROW_COUNT = 2 * Math.floor(Math.floor((document.documentElement.clientHeight) / 25) / 2) - 3;\n        const COLUMN_COUNT = 2 * Math.floor(Math.floor(document.documentElement.clientWidth / 25) / 2) - 1;\n        const START_NODE_ROW = Math.floor(ROW_COUNT / 2);\n        const FINISH_NODE_ROW = Math.floor(ROW_COUNT / 2);\n        const START_NODE_COL = Math.floor(COLUMN_COUNT / 4);\n        const FINISH_NODE_COL = Math.floor(3 * COLUMN_COUNT / 4);\n        this.setState({ ROW_COUNT, COLUMN_COUNT, START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL });\n    }\n    componentDidMount = () => {\n        const grid = this.getInitialGrid();\n        this.setState({ grid });\n    }\n\n    render() {\n        return (\n            <div>\n                <Navbar\n                    dfs={() => this.visualize('DFS')}\n                    bfs={() => this.visualize('BFS')}\n                    dijkstra={() => this.visualize('Dijkstra')}\n                    clearGrid={() => this.clearGrid()}\n                    resetGrid={() => this.resetGrid()}\n                    clearWallsandWeights={() => this.clearWallsandWeights()}\n                    mazify={() => this.mazes('maze')}\n                    hmazify={() => this.mazes('hSkew')}\n                    vmazify={() => this.mazes('vSkew')}\n                    kruskalMazify={() => this.mazes('kruskals')}\n                    primMazify={() => this.mazes('prims')}\n                    weightMazify={() => this.mazes('weightMaze')}\n                    wallMazify={() => this.mazes('wallMaze')}\n                    navbarHeight={this.navbarHeight}\n                    weightWallToggle={() => this.toggleWeightWallToggle()}\n                    toggleCanvas={() => this.props.toggleCanvas()}\n                    isCanvas={this.props.isCanvas}\n                ></Navbar>\n                <table className=\"center grid-container\" >\n                    <tbody className=\"grid\">\n                        {\n                            this.state.grid.map((row, rowID) => {\n                                return (\n                                    <tr key={rowID} >\n                                        {\n                                            row.map((node, nodeID) => {\n                                                const { row, col, isFinish, isStart, isWall, weight } = node;\n\n                                                return (\n                                                    <Node\n                                                        key={nodeID}\n                                                        row={row}\n                                                        col={col}\n                                                        weight={weight}\n                                                        isFinish={isFinish}\n                                                        isStart={isStart}\n                                                        isWall={isWall}\n                                                        onMouseDown={(x, y) => { this.onCellDown(x, y) }}\n                                                        onMouseEnter={(x, y) => this.onCellEnter(x, y)}\n                                                        onMouseUp={() => this.onCellRelease()}\n                                                        onMouseLeave={(x, y) => this.onCellLeave(x, y)}\n                                                    ></Node>\n                                                );\n                                            })\n                                        }\n\n                                    </tr>\n                                );\n                            })\n                        }\n                    </tbody>\n                </table>\n            </div>\n        )\n    }\n}\n\nexport default PathfindingVisualizer;\n","export function wallMaze(grid) {\n    grid.forEach(row => {\n        row.forEach(node => {\n            node.isWall = false;\n            if (!node.isStart && !node.isFinish) {\n                const random = Math.floor(Math.random() * 4);\n                if (random === 0) {\n                    node.isWall = true;\n                    node.weight = 1;\n                }\n            }\n        });\n    });\n    return grid;\n}","// BFS\n\nexport function bfs (grid,startNode,finishNode) {\n    const visitedNodesInOrder = [];\n    let bfsQueue = [startNode];\n    startNode.isVisited = true;\n    const childDirections = [[1,0],[0,1],[-1,0],[0,-1]] ;\n\n    while(bfsQueue.length)\n    {\n        const currentNode = bfsQueue.shift();\n        if (currentNode === finishNode) return visitedNodesInOrder;\n        visitedNodesInOrder.push(currentNode);\n        const {row,col} = currentNode;\n\n        childDirections.forEach(direction => {\n            let x = row + direction[0];\n            let y = col + direction[1];\n\n            if(x>=0 && y>=0 && x<grid.length && y<grid[0].length && !grid[x][y].isWall && !grid[x][y].isVisited)\n            {\n                bfsQueue.push(grid[x][y]);\n                grid[x][y].isVisited = true;\n                grid[x][y].parent = currentNode;\n            }\n        });\n    }\n    return visitedNodesInOrder;\n}\n\n","import React, { useRef, useState } from \"react\";\n\nexport const CanvasContext = React.createContext();\n\nexport const CanvasProvider = ({ children }) => {\n    const [isDrawing, setIsDrawing] = useState(false);\n\n    const [nodeDrawing, setNodeDrawing] = useState(true);\n    const [index,setIndex] = useState(0);\n    const canvasRef = useRef(null);\n    const contextRef = useRef(null);\n\n    const prepareCanvas = (height, width) => {\n        const canvas = canvasRef.current\n        canvas.width = width;\n        canvas.height = height;\n        canvas.style.width = `${width}px`;\n        canvas.style.height = `${height}px`;\n\n        const context = canvas.getContext(\"2d\");\n        context.lineCap = \"round\";\n        context.strokeStyle = \"black\";\n        context.lineWidth = 1;\n        contextRef.current = context;\n    };\n\n    const toggleNodeDrawing = () => {\n        setNodeDrawing(!nodeDrawing);\n    }\n\n    const [nodesOfGraph, pushNode] = useState([]);\n\n    const squareDistance = (node, x, y) => {\n        return Math.pow(node.centerX - x, 2) + Math.pow(node.centerY - y, 2);\n    }\n\n    const [startNode, setStartNode] = useState(null);\n    let currentCoordinates = null;\n    const whichNode = (x, y) => {\n        let node = null;\n        for (let i = 0; i < nodesOfGraph.length; i++) {\n            if (squareDistance(nodesOfGraph[i], x, y) <= 1600) {\n                node = nodesOfGraph[i];\n                return node;\n            }\n        }\n        return node;\n    }\n\n    const writeText = (info, style = {}) => {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        const { text, x, y } = info;\n        const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\n\n        ctx.beginPath();\n        ctx.font = fontSize + 'px ' + fontFamily;\n        ctx.textAlign = textAlign;\n        ctx.textBaseline = textBaseline;\n        ctx.fillStyle = color;\n        ctx.fillText(text, x, y);\n        ctx.stroke();\n    }\n\n    const startDrawing = ({ nativeEvent }) => {\n        if (nodeDrawing) {\n            const { offsetX, offsetY } = nativeEvent;\n            if (whichNode(offsetX, offsetY)) return;\n\n            setIndex((prevIndex)=> prevIndex + 1);\n            const canvas = canvasRef.current;\n            const ctx = canvas.getContext(\"2d\");\n\n\n            ctx.beginPath();\n            ctx.arc(offsetX, offsetY, 20, 0, Math.PI * 2, false);\n            ctx.stroke();\n            ctx.closePath();\n            \n            const node = {\n                centerX: offsetX,\n                centerY: offsetY,\n                id: index,\n                children: [],\n                isVisited:false,\n                parent:null,\n                costFromSource:Number.POSITIVE_INFINITY,\n            };\n            pushNode([...nodesOfGraph, node]);\n            writeText({text : `${node.id}`,x : node.centerX-10,y : node.centerY-10});\n        }\n        else {\n            if (!isDrawing) {\n                const { offsetX, offsetY } = nativeEvent;\n\n                const start = whichNode(offsetX, offsetY);\n                setStartNode(start);\n\n                if (start) {\n                    setIsDrawing(true);\n                    currentCoordinates = { x: offsetX, y: offsetY };\n                    contextRef.current.beginPath();\n                    contextRef.current.moveTo(offsetX, offsetY);\n                }\n            }\n        }\n    };\n\n    const [currentEdgeWeight,setCurrentEdgeWeight] = useState(0);\n    const finishDrawing = () => {\n        if (!nodeDrawing) {\n\n            if (isDrawing && currentCoordinates) {\n                setIsDrawing(false);\n\n                const { x, y } = currentCoordinates;\n                const end = whichNode(x, y);\n\n                if (!end) {\n                    contextRef.current.closePath();\n                }\n                else if (end.id === startNode.id) {\n                    contextRef.current.closePath();\n                }\n                else {\n                    contextRef.current.moveTo(startNode.centerX, startNode.centerY);\n                    contextRef.current.lineTo(end.centerX, end.centerY);\n                    contextRef.current.stroke();\n                    contextRef.current.closePath();\n                    \n                    let c =false;\n                    for(let i=0;i<startNode.children.length;i++){\n                        if(startNode.children[i].node === end){\n                            c = true;\n                            break;\n                        }\n                    }\n                    if(!c){\n                        const weight = currentEdgeWeight;\n                        const x = (startNode.centerX + end.centerX) / 2;\n                        const y = (startNode.centerY + end.centerY) / 2;\n                        startNode.children.push({ node: end, weight });\n                        end.children.push({ node: startNode, weight });\n                        writeText({ text: (weight?weight:''), x, y });\n                    }\n                }\n                currentCoordinates = null;\n                setStartNode(null);\n            }\n        }\n    };\n\n    const draw = ({ nativeEvent }) => {\n        const { offsetX, offsetY } = nativeEvent;\n        if (!nodeDrawing) {\n            if (isDrawing) {\n                currentCoordinates = { x: offsetX, y: offsetY };\n            }\n        }\n    };\n\n    const clearCanvas = () => {\n        const canvas = canvasRef.current;\n        const context = canvas.getContext(\"2d\");\n        context.fillStyle = \"white\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n        pushNode([]);\n        setIndex(1);\n    }\n\n    return (\n        <CanvasContext.Provider\n            value={{\n                canvasRef,\n                contextRef,\n                prepareCanvas,\n                startDrawing,\n                finishDrawing,\n                clearCanvas,\n                draw,\n                toggleNodeDrawing,\n                nodeDrawing,\n                nodesOfGraph,\n                pushNode,\n                setIndex,\n                setCurrentEdgeWeight,\n            }}\n        >\n            {children}\n        </CanvasContext.Provider>\n    );\n};\n\n","import React, { useEffect, useContext, useLayoutEffect, useState } from \"react\";\nimport { CanvasContext } from \"./CanvasContext\";\n\nfunction CanvasBoard(props) {\n    const {\n        canvasRef,\n        prepareCanvas,\n        startDrawing,\n        finishDrawing,\n        draw,\n        toggleNodeDrawing,\n        nodeDrawing,\n        nodesOfGraph,\n        clearCanvas,\n        pushNode,\n        setIndex,\n        setCurrentEdgeWeight,\n    } = useContext(CanvasContext);\n\n    const emptyTheGraph = () => {\n        pushNode([]);\n        setIndex(1);\n    }\n\n    useEffect(() => {\n        prepareCanvas(props.height, props.width);\n        clearCanvas();\n        props.settingStartNode(null);\n        props.settingEndNode(null);\n    }, []);\n    const [startNode, setStartNode] = useState(0);\n    const [endNode, setEndNode] = useState(0);\n    useEffect(() => {\n        props.settingGraph(nodesOfGraph);\n        if (!startNode) props.settingStartNode((nodesOfGraph.length ? nodesOfGraph[0] : null));\n        if (!endNode) props.settingEndNode(nodesOfGraph.length ? nodesOfGraph[nodesOfGraph.length - 1] : null);\n        if (props.emptyGraphCall) {\n            emptyTheGraph();\n            props.toggleEmptyTheGraph();\n        }\n    }, [nodesOfGraph, props.emptyGraphCall]);\n\n\n\n    const startNodeUpdate = (event) => {\n        const startIndex = event.target.value;\n        setStartNode(startIndex);\n        if (startIndex != 0 && startIndex <= nodesOfGraph.length) props.settingStartNode(nodesOfGraph[startIndex - 1]);\n        else alert('Not a valid start node');\n    }\n    const endNodeUpdate = (event) => {\n        const endIndex = event.target.value;\n        setEndNode(endIndex);\n        if (endIndex != 0 && endIndex <= nodesOfGraph.length) props.settingEndNode(nodesOfGraph[endIndex - 1]);\n        else alert('Not a valid start node');\n    }\n\n///////////////////////////////////////// try doing without usingStates\n    const [weightNodeA,setWeightNodeA] = useState(0);\n    const [weightNodeB, setWeightNodeB] = useState(0);\n    const [weight,setWeight] = useState(0);\n    const weightNodeAUpdate = (event)=>{\n        const nodeIndex = event.target.value;\n        setWeightNodeA(nodeIndex);\n    }\n    const weightNodeBUpdate = (event) => {\n        const nodeIndex = event.target.value;\n        setWeightNodeB(nodeIndex);\n    }\n    const weightUpdate=(event)=>{\n        const weight=parseInt(event.target.value);\n        setWeight(weight);\n        setCurrentEdgeWeight(weight);\n    }\n    const writeText = (info, style = {}) => {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        const { text, x, y } = info;\n        const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\n\n        ctx.beginPath();\n        ctx.font = fontSize + 'px ' + fontFamily;\n        ctx.textAlign = textAlign;\n        ctx.textBaseline = textBaseline;\n        ctx.fillStyle = color;\n        ctx.fillText(text, x, y);\n        ctx.stroke();\n    }\n    const addWeightToEdge = () => {\n        const startId = weightNodeA;\n        const endId = weightNodeB;\n        const weightFinal = weight;\n        if(startId > 0 && endId>0 && startId<=nodesOfGraph.length && endId<=nodesOfGraph.length){\n            const startNode = nodesOfGraph[startId - 1];\n            const endNode = nodesOfGraph[endId - 1];\n            for (let i = 0; i < startNode.children.length; i++) {\n                let { node } = startNode.children[i];\n                if (node === endNode) {\n                    startNode.children[i].weight = weightFinal;\n                    for (let j = 0; j < endNode.children.length; j++) {\n                        let { node, weight } = endNode.children[j];\n                        if (node === startNode) {\n                            endNode.children[j].weight = weightFinal;\n                            const x = (startNode.centerX + endNode.centerX)/2;\n                            const y = (startNode.centerY + endNode.centerY)/2;\n                            writeText({text:weightFinal,x,y});\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        alert('No such edge exists');\n    }\n/////////////////////////////////////////////////////////////////////////\n    let edgeWeightInput = <div><a>Current edge weight</a>\n        <input id=\"edgeWeight\" onChange={weightUpdate} type=\"number\" value={weight} /></div>;\n    if(nodeDrawing){\n        edgeWeightInput = <div></div>\n    }\n    return (\n        <>\n            {/* <section id=\"canvas-container\"> */}\n            <div id=\"wrapper\" class=\"toggled\">\n                <div id=\"sidebar-wrapper\">\n                    <ul className=\"sidebar-nav\">\n                        <li className=\"sidebar-brand\"> <a href=\"#\"> Control Panel </a> </li>\n                        <li> \n                            <a href=\"#\" onClick={toggleNodeDrawing}>Add {nodeDrawing ? 'Edge' : 'Node'}</a> \n                            {edgeWeightInput}\n                        </li>\n                        <li>\n                            <a>Start Node</a>\n                            <input id=\"startValue\" type = \"number\" placeholder={nodesOfGraph.length ? '1' : '0'} onChange={startNodeUpdate} />\n                            <a>End Node</a>\n                            <input id=\"endValue\" type=\"number\" placeholder={nodesOfGraph.length} onChange={endNodeUpdate} />\n                        </li>\n                        {/* <li>\n                            <a>Add Weight</a>\n                            <a>Start Node</a>\n                            <input onChange={weightNodeAUpdate} type=\"number\" value ={weightNodeA}/>\n                            <a>End Node</a>\n                            <input onChange={weightNodeBUpdate} type=\"number\" value = {weightNodeB}/>\n                            <a>Weight</a>\n                            <input id=\"edgeWeight\" onChange={weightUpdate} type=\"number\" value = {weight}/>\n                            <button onClick = {addWeightToEdge}>Submit</button>\n                        </li> */}\n                    </ul>\n                </div>\n            </div>\n            <canvas id='canvas'\n                className=\"centercanvas\"\n                onMouseDown={props.isRunning?()=>{}:startDrawing}\n                onMouseUp={props.isRunning ? () => { } :finishDrawing}\n                onMouseMove={draw}\n                ref={canvasRef}\n            ></canvas>\n\n            <button ></button>\n            <br></br>\n            {/* </section> */}\n        </>\n    )\n}\n\nexport default CanvasBoard;","// BFS\nconst createEdge = (nodeA,nodeB)=>{\n    if(nodeA === null){\n        const xB = nodeB.centerX;\n        const yB = nodeB.centerY;\n        return {xB,yB,xB,yB};\n    }\n    const xA = nodeA.centerX;\n    const yA = nodeA.centerY;\n    const xB = nodeB.centerX;\n    const yB = nodeB.centerY;\n    const edge = {xA,yA,xB,yB};\n    return edge;\n}\n\nexport function bfs(graph, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    const visitedEdgesInOrder = [];\n    let bfsQueue = [startNode];\n    startNode.isVisited = true;\n\n    while (bfsQueue.length) {\n        const currentNode = bfsQueue.shift();\n        visitedNodesInOrder.push(currentNode);\n        visitedEdgesInOrder.push(createEdge(currentNode.parent, currentNode));\n        if (currentNode === finishNode) {\n            return { visitedNodesInOrder, visitedEdgesInOrder }\n        };\n        currentNode.children.forEach(childObject => {\n            const child = childObject.node;\n            if(!child.isVisited){\n                child.isVisited = true;\n                child.parent = currentNode;\n                bfsQueue.push(child);\n            }\n        });\n    }\n    return { visitedNodesInOrder, visitedEdgesInOrder };\n}","// DFS\nconst createEdge = (nodeA, nodeB) => {\n    const xA = nodeA.centerX;\n    const yA = nodeA.centerY;\n    const xB = nodeB.centerX;\n    const yB = nodeB.centerY;\n    const edge = { xA, yA, xB, yB };\n    return edge;\n}\n\nfunction getChildren(node) {\n    const childElements = [];\n\n    node.children.forEach((childObject) => {\n        const child = childObject.node;\n        if (!child.isVisited) {\n            childElements.push(child);\n        }\n    });\n\n    return childElements;\n}\n\nexport function dfs(graph, startNode, finishNode) {\n    const visitedNodesInOrder = [startNode];\n    const visitedEdgesInOrder = [];\n    startNode.isVisited = true;\n    let currentNode = startNode;\n    let dfsStack = [currentNode];\n    while (dfsStack.length) {\n        if (currentNode === finishNode) { \n            return { visitedNodesInOrder, visitedEdgesInOrder }; \n        }\n        const childElements = getChildren(currentNode);\n        if (childElements.length) {\n            childElements[0].parent = currentNode;\n            visitedEdgesInOrder.push(createEdge(currentNode, childElements[0]));\n            currentNode = childElements[0];\n            currentNode.isVisited = true;\n            visitedNodesInOrder.push(currentNode);\n            dfsStack.push(currentNode);\n        }\n        else {\n            dfsStack.pop();\n            currentNode = dfsStack[dfsStack.length - 1];\n        }\n    }\n    return { visitedNodesInOrder, visitedEdgesInOrder };\n}","// Dijkstra\n// still raw\n\nconst createEdge = (nodeA, nodeB) => {\n    const xA = nodeA.centerX;\n    const yA = nodeA.centerY;\n    const xB = nodeB.centerX;\n    const yB = nodeB.centerY;\n    const edge = { xA, yA, xB, yB };\n    return edge;\n}\n\nfunction getChildren(currentNode,visitedEdgesInOrder) {\n    const childNodes = [];\n    currentNode.children.forEach(childObject => {\n        const { node, weight } = childObject;\n        if (!node.isVisited) {\n            childNodes.push(node);\n            if (node.costFromSource > currentNode.costFromSource + weight) {\n                node.parent = currentNode;\n                visitedEdgesInOrder.push(createEdge(currentNode,node));\n            }\n            node.costFromSource = Math.min(node.costFromSource, currentNode.costFromSource + weight);\n        }\n        else if (node.isVisited) {\n            if (node.costFromSource > currentNode.costFromSource + weight) {\n                node.parent = currentNode;\n                visitedEdgesInOrder.push(createEdge(currentNode, node));\n            }\n            node.costFromSource = Math.min(node.costFromSource, currentNode.costFromSource + weight);\n        }\n    })\n    return childNodes;\n}\n\nfunction extractMinIndex(dijkstraPQ) {\n    let minNode = dijkstraPQ[0];\n    let minNodeIndex = 0;\n    for (let i = 1; i < dijkstraPQ.length; i++) {\n        let currentNode = dijkstraPQ[i];\n        if (minNode.costFromSource > currentNode.costFromSource) {\n            minNode = currentNode;\n            minNodeIndex = i;\n        }\n    }\n    return minNodeIndex;\n}\n\nexport function dijkstra(graph, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    const visitedEdgesInOrder = [];\n\n    let currentNode;\n    let dijkstraPQ = [startNode];\n    startNode.costFromSource = 0;\n    startNode.isVisited = true;\n    while (dijkstraPQ.length) {\n\n        const minIndex = extractMinIndex(dijkstraPQ);\n        currentNode = dijkstraPQ[minIndex];\n        if (currentNode === finishNode) {\n            visitedNodesInOrder.push(currentNode);\n            return { visitedNodesInOrder, visitedEdgesInOrder };\n        }\n\n        visitedNodesInOrder.push(currentNode);\n        const childNodes = getChildren(currentNode,visitedEdgesInOrder);\n        childNodes.forEach(node => {\n            dijkstraPQ.push(node);\n            node.isVisited = true;\n        });\n        dijkstraPQ.splice(minIndex, 1);\n    }\n    return {visitedNodesInOrder,visitedEdgesInOrder};\n}\n\n","const createEdge = (nodeA, nodeB) => {\n    const xA = nodeA.centerX;\n    const yA = nodeA.centerY;\n    const xB = nodeB.centerX;\n    const yB = nodeB.centerY;\n    const edge = { xA, yA, xB, yB };\n    return edge;\n}\n\nconst writeText = (info, style = {}) => {\n    const canvas = document.getElementById('canvas');\n    const ctx = canvas.getContext(\"2d\");\n    const { text, x, y } = info;\n    const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\n\n    ctx.beginPath();\n    ctx.font = fontSize + 'px ' + fontFamily;\n    ctx.textAlign = textAlign;\n    ctx.textBaseline = textBaseline;\n    ctx.fillStyle = color;\n    ctx.fillText(text, x, y);\n    ctx.stroke();\n}\n\nexport function visitAllEdges(graph) {\n    let canvas = document.getElementById('canvas');\n    const ctx = canvas.getContext(\"2d\");\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    graph.forEach((node) => {\n        node.isVisited = false;\n        node.parent = null;\n        node.costFromSource = Number.POSITIVE_INFINITY;\n    });\n\n    graph.forEach((node) => {\n        writeText({ text: `${node.id}`, x: node.centerX - 35, y: node.centerY - 35 });\n        if (!node.isVisited) {\n\n            ctx.strokeStyle = \"#000000\";\n            let { centerX, centerY } = node;\n            ctx.beginPath();\n            ctx.moveTo(centerX, centerY);\n            ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, true);\n            ctx.stroke();\n            ctx.closePath();\n\n            let bfsQueue = [node];\n            while (bfsQueue.length) {\n                const currentNode = bfsQueue.shift();\n                currentNode.isVisited = true;\n                currentNode.children.forEach(childObject => {\n                    const child = childObject.node;\n                    if (!child.isVisited) {\n                        const edge = createEdge(currentNode, child);\n                        const { xA, yA, xB, yB } = edge;\n                        const x = (xA + xB) / 2;\n                        const y = (yA + yB) / 2;\n                        const weight = (childObject.weight ? childObject.weight:'');\n                        writeText({text:weight,x,y});\n                        ctx.beginPath();\n                        ctx.moveTo(xA, yA);\n                        ctx.lineTo(xB, yB);\n                        ctx.stroke();\n                        ctx.closePath();\n                        ctx.beginPath();\n                        ctx.arc(xB, yB, 20, 0, Math.PI * 2, false);\n                        ctx.stroke();\n                        ctx.closePath();\n                        bfsQueue.push(child);\n                    }\n                });\n            }\n        }\n    });\n\n    graph.forEach((node) => {\n        node.isVisited = false;\n        node.parent = null;\n        node.costFromSource = Number.POSITIVE_INFINITY;\n    });\n}","import DisjointSet from '../../Data Structures/disjointSet';\n\nconst getEdgeWeight = (nodeA, nodeB) => {\n    for (let i = 0; i < nodeA.children.length; i++) {\n        const { node, weight } = nodeA.children[i];\n        if (node === nodeB) {\n            return weight;\n        }\n    }\n    return null;\n}\nconst createEdge = (nodeA, nodeB) => {\n    const edgeWeight = getEdgeWeight(nodeA, nodeB);\n    const edge = { nodeA, nodeB, edgeWeight };\n    return edge;\n}\n\nfunction compare(edgeA, edgeB) {\n    return edgeA.edgeWeight - edgeB.edgeWeight;\n}\n\nexport function kruskalsMST(graph) {\n    let disjointSet = new DisjointSet((node) => {\n        return node.id;\n    });\n    graph.forEach((node) => {\n        node.isVisited = false;\n        node.parent = null;\n        node.costFromSource = Number.POSITIVE_INFINITY;\n        disjointSet.makeSet(node);\n    });\n    const graphEdges = [];\n    graph.forEach((node) => {\n        if (!node.isVisited) {\n            let bfsQueue = [node];\n            while (bfsQueue.length) {\n                const currentNode = bfsQueue.shift();\n                currentNode.isVisited = true;\n                currentNode.children.forEach(childObject => {\n                    const child = childObject.node;\n                    if (!child.isVisited) {\n                        const edge = createEdge(currentNode, child);\n                        graphEdges.push(edge);\n                        bfsQueue.push(child);\n                    }\n                });\n            }\n        }\n    });\n    graphEdges.sort(compare);\n\n    const kruskalSelectedEdges = [];\n    graphEdges.forEach((edge) => {\n        const {nodeA,nodeB} = edge;\n        if(!disjointSet.inSameSet(nodeA,nodeB)){\n            kruskalSelectedEdges.push(edge);\n            disjointSet.union(nodeA,nodeB);\n        }\n    });\n\n    return kruskalSelectedEdges;\n\n}","import DisjointSet from '../../Data Structures/disjointSet';\n\nconst getEdgeWeight = (nodeA, nodeB) => {\n    for (let i = 0; i < nodeA.children.length; i++) {\n        const { node, weight } = nodeA.children[i];\n        if (node === nodeB) {\n            return weight;\n        }\n    }\n    return null;\n}\nconst createEdge = (nodeA, nodeB) => {\n    const edgeWeight = getEdgeWeight(nodeA, nodeB);\n    const edge = { nodeA, nodeB, edgeWeight };\n    return edge;\n}\n\nfunction compare(edgeA, edgeB) {\n    return edgeA.edgeWeight - edgeB.edgeWeight;\n}\n\nexport function primsMST(graph) {\n    let disjointSet = new DisjointSet((node) => {\n        return node.id;\n    });\n    graph.forEach((node) => {\n        node.isVisited = false;\n        node.parent = null;\n        node.costFromSource = Number.POSITIVE_INFINITY;\n        disjointSet.makeSet(node);\n    });\n    const primSelectedEdges = [];\n\n    let currentNode = graph[0];\n    const graphEdgesQueue = [];\n    for(let i=0;i<currentNode.children.length;i++){\n        const {node,weight} = currentNode.children[i];\n        graphEdgesQueue.push(createEdge(currentNode,node));\n    }\n    graphEdgesQueue.sort(compare);\n    \n    while(graphEdgesQueue.length){\n        const { nodeA, nodeB} = graphEdgesQueue[0];\n        if(!disjointSet.inSameSet(nodeA,nodeB)){\n            disjointSet.union(nodeA,nodeB);\n            currentNode = graphEdgesQueue[0].nodeB;\n            primSelectedEdges.push(graphEdgesQueue.shift());\n            for (let i = 0; i < currentNode.children.length; i++) {\n                const { node } = currentNode.children[i];\n                graphEdgesQueue.push(createEdge(currentNode, node));\n            }\n            graphEdgesQueue.sort(compare);\n        }\n        else graphEdgesQueue.shift();\n    }\n\n    return primSelectedEdges;\n}","import React, { useContext } from 'react';\nimport './Canvas.css';\nimport Navbar from '../Navbar';\nimport CanvasBoard from './CanvasBoard';\nimport { CanvasProvider } from './CanvasContext';\nimport { bfs } from './Algorithms/bfs';\nimport { dfs } from './Algorithms/dfs';\nimport { dijkstra } from './Algorithms/dijkstra';\nimport { visitAllEdges } from \"./Algorithms/visitAllEdges\";\nimport { kruskalsMST } from './Algorithms/kruskals';\nimport { primsMST } from './Algorithms/prims';\n\nclass Canvas extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            navbarHeight: 0,\n            height: 0,\n            width: 0,\n            graphOfNodes: [],\n            isRunning: false,\n            emptyGraphCall: false,\n            startNode: null,\n            endNode: null,\n        }\n    }\n    // for togling b/w grid and canvas\n    toggleCanvas = () => {\n        const canvasOrGrid = !this.state.canvasOrGrid;\n        this.setState({ canvasOrGrid });\n        this.props.toggleCanvas();\n    }\n\n    toggleEmptyTheGraph = () => {\n        const emptyGraphCall = !this.state.emptyGraphCall;\n        this.setState({ emptyGraphCall });\n    }\n    \n\n    settingStartNode = (startNode) => {\n        this.setState({ startNode });\n    }\n    settingEndNode = (endNode) => {\n        this.setState({ endNode });\n    }\n    settingGraph = (graphOfNodes) => {\n        this.setState({ graphOfNodes });\n    }\n\n    redrawGraph = () => {\n        const graphOfNodes = this.state.graphOfNodes;\n        visitAllEdges(graphOfNodes);\n    }\n    clearCanvas = () => {\n        this.setState({ emptyGraphCall: true });\n        const canvas = document.getElementById('canvas');\n        const context = canvas.getContext(\"2d\");\n        context.fillStyle = \"white\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    visualize(algo) {\n        if (!this.state.isRunning) {\n            const graphOfNodes = this.state.graphOfNodes;\n            if (!graphOfNodes.length) {\n                alert('Canvas is empty');\n                return;\n            }\n            this.setState({ isRunning: true });\n            this.redrawGraph();\n            let startNode = this.state.startNode, finishNode = this.state.endNode;\n\n            let visitedNodesInOrder1;\n            let visitedEdgesInOrder1;\n            switch (algo) {\n                case 'Dijkstra':\n                    {\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = dijkstra(graphOfNodes, startNode, finishNode);\n                        visitedNodesInOrder1 = visitedNodesInOrder;\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\n                        break;\n                    }\n                case 'BFS':\n                    {\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = bfs(graphOfNodes, startNode, finishNode);\n                        visitedNodesInOrder1 = visitedNodesInOrder;\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\n                        break;\n                    }\n                case 'DFS':\n                    {\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = dfs(graphOfNodes, startNode, finishNode);\n                        visitedNodesInOrder1 = visitedNodesInOrder;\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\n                        break;\n                    }\n                default:\n                    // should never get here\n                    break;\n            }\n            visitedNodesInOrder1.forEach(node => {\n                console.log(node.id, node.costFromSource);\n            });\n            this.animate(visitedNodesInOrder1, visitedEdgesInOrder1, algo, finishNode);\n        }\n    }\n\n\n    animate = (visitedNodesInOrder, visitedEdgesInOrder, algo, finishNode) => {\n        let canvas = document.getElementById('canvas');\n        let ctx = canvas.getContext('2d');\n        ctx.fillStyle = \"green\";\n        ctx.strokeStyle = '#ff0000';\n        ctx.lineWidth = 1;\n\n        let { centerX, centerY } = visitedNodesInOrder[0];\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, false);\n        ctx.fill();\n        ctx.closePath();\n\n        for (let i = 0; i < visitedEdgesInOrder.length; i++) {\n            const { xA, yA, xB, yB } = visitedEdgesInOrder[i];\n\n            setTimeout(() => {\n                setTimeout(() => {\n                    ctx.beginPath();\n                    ctx.moveTo(xA, yA);\n                    ctx.lineTo(xB, yB);\n                    ctx.stroke();\n                    ctx.closePath();\n                }, 500);\n\n                setTimeout(() => {\n                    ctx.beginPath();\n                    ctx.arc(xB, yB, 20, 0, Math.PI * 2, false);\n                    ctx.fill();\n                    ctx.closePath();\n                }, 1000);\n            }, i * 1000);\n\n        }\n        if (visitedNodesInOrder[visitedNodesInOrder.length - 1] === finishNode) {\n            setTimeout(() => {\n                this.animateShortestPath(finishNode, visitedNodesInOrder);\n            }, 1000 * (visitedEdgesInOrder.length + 1) + 100);\n        }\n        else {\n            setTimeout(() => {\n                ctx.fillStyle = \"#ffffff\";\n                ctx.strokeStyle = '#000000';\n                this.setState({ isRunning: false });\n                alert('node not reachable');\n            }, 1000 * visitedNodesInOrder.length + 100);\n        }\n\n    }\n    animateShortestPath = (endNode, visitedNodesInOrder) => {\n        let shortestPathNodes = [];\n        let currentNode = endNode;\n        while (currentNode) {\n            shortestPathNodes.push(currentNode);\n            currentNode = currentNode.parent;\n        }\n        let canvas = document.getElementById('canvas');\n        let ctx = canvas.getContext('2d');\n        ctx.fillStyle = \"yellow\";\n\n        for (let i = shortestPathNodes.length - 1; i >= 0; i--) {\n            setTimeout(() => {\n                const node = shortestPathNodes[i];\n                const { centerX, centerY } = node;\n                ctx.beginPath();\n                ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, false);\n                ctx.fill();\n                ctx.closePath();\n            }, (shortestPathNodes.length - 1 - i) * 500);\n        }\n        setTimeout(() => {\n            ctx.fillStyle = \"#ffffff\";\n            ctx.strokeStyle = '#000000';\n            this.setState({ isRunning: false });\n            shortestPathNodes = [];\n        }, 500 * (shortestPathNodes.length) + 1000);\n    }\n\n    visualizeMST = (algo) => {\n        if (!this.state.isRunning) {\n            const graphOfNodes = this.state.graphOfNodes;\n            if (!graphOfNodes.length) {\n                alert('Canvas is empty');\n                return;\n            }\n            this.setState({ isRunning: true });\n            this.redrawGraph();\n            let MSTedges = [];\n            switch (algo) {\n                case 'Kruskal':\n                    {\n                        MSTedges = kruskalsMST(graphOfNodes);\n                        break;\n                    }\n                case 'Prims':\n                    {\n                        MSTedges = primsMST(graphOfNodes);\n                        break;\n                    }\n                default:\n                    // do nothing\n                    break;\n            }\n            if (MSTedges.length) this.animateMST(MSTedges);\n            else {\n                // some error occurred\n                this.setState({ isRunning: false });\n            }\n        }\n    }\n    animateMST = (MSTedges) => {\n        let canvas = document.getElementById('canvas');\n        let ctx = canvas.getContext('2d');\n        ctx.strokeStyle = '#ff0000';\n        ctx.lineWidth = 5;\n\n        for (let i = 0; i < MSTedges.length; i++) {\n            setTimeout(() => {\n                const { nodeA, nodeB } = MSTedges[i];\n                const xA = nodeA.centerX;\n                const yA = nodeA.centerY;\n                const xB = nodeB.centerX;\n                const yB = nodeB.centerY;\n                ctx.beginPath();\n                ctx.moveTo(xA, yA);\n                ctx.lineTo(xB, yB);\n                ctx.stroke();\n                ctx.closePath();\n            }, i * 500);\n        }\n        setTimeout(() => {\n            ctx.strokeStyle = '#000000';\n            ctx.lineWidth = 1;\n            this.setState({ isRunning: false });\n        }, MSTedges.length * 500 + 100);\n    }\n\n\n    render() {\n        const height = document.documentElement.clientHeight - 50;\n        const width = document.documentElement.clientWidth - 30;\n        return (\n            <div>\n                <CanvasProvider>\n                    <Navbar\n                        isCanvas={this.props.isCanvas}\n                        toggleCanvas={() => this.toggleCanvas()}\n                        bfs={() => this.visualize('BFS')}\n                        dfs={() => this.visualize('DFS')}\n                        dijkstra={() => this.visualize('Dijkstra')}\n                        clearGrid={() => this.redrawGraph()}\n                        resetGrid={() => this.clearCanvas()}\n                        kruskalMST={() => this.visualizeMST('Kruskal')}\n                        primMST={() => this.visualizeMST('Prims')}\n                    ></Navbar>\n                    <CanvasBoard\n                        height={height}\n                        width={width}\n                        settingGraph={this.settingGraph}\n                        settingStartNode={this.settingStartNode}\n                        settingEndNode={this.settingEndNode}\n                        emptyGraphCall={this.state.emptyGraphCall}\n                        toggleEmptyTheGraph={this.toggleEmptyTheGraph}\n                        isRunning={this.state.isRunning}\n                    ></CanvasBoard>\n                </CanvasProvider>\n            </div>\n        )\n    }\n}\n\nexport default Canvas;","import React from 'react';\nimport './App.css';\n// import Navbar from './Navbar';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer'\nimport Canvas from './Canvas/Canvas'\n\nclass App extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {\n      canvas: false,\n    }\n  }\n\n  toggleCanvas = ()=>{\n    const canvas = !this.state.canvas;\n    this.setState({canvas});\n  }\n\n  render(){\n\n    if(!this.state.canvas){\n      return (\n        <div className=\"App\">\n          <PathfindingVisualizer\n              toggleCanvas={()=>this.toggleCanvas()}\n              isCanvas = {this.state.canvas}\n          ></PathfindingVisualizer>\n        </div>\n      )\n    }\n    else {\n      return (\n        <div className=\"App\">\n          <Canvas\n            toggleCanvas={() => this.toggleCanvas()}\n            isCanvas={this.state.canvas}\n          ></Canvas>\n        </div>\n      )\n    } \n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}